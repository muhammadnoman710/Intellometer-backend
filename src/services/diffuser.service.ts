import prisma from '../config/prisma';

export const DiffuserService = {
  // create returns diffuser; systemName auto-generated by smallest available number
  async create(zoneId: string, userId: number, label?: string, sizeInput?: string, sizeUnit?: string, deviceIdentifier?: string) {
    // check zone ownership
    const zone = await prisma.zone.findUnique({ where: { id: zoneId }, include: { project: true } });
    if (!zone || zone.project.userId !== userId) throw new Error("Zone not found or unauthorized");

    // enforce max 15 diffusers per zone
    const count = await prisma.diffuser.count({ where: { zoneId } });
    if (count >= 15) throw new Error("Max 15 diffusers allowed per zone");

    // compute next systemName number (smallest missing)
    const existing = await prisma.diffuser.findMany({ where: { zoneId }, select: { systemName: true } });
    const nums = existing
      .map((d: { systemName: string }) => parseInt(d.systemName.replace(/^Diffuser\s+/i, ""), 10))
      .filter((n: number) => !isNaN(n))
      .sort((a: number, b: number) => a - b);

    let nextNum = 1;
    for (let i = 1; i <= 15; i++) {
      if (!nums.includes(i)) { nextNum = i; break; }
    }
    const systemName = `Diffuser ${nextNum}`;

    const data: any = {
      zoneId,
      systemName,
      label,
      size_input: sizeInput,
      size_unit: sizeUnit,
      deviceIdentifier,
    };

    const created = await prisma.diffuser.create({ data });
    return created;
  },

  async list(zoneId: string, userId: number) {
    // ownership checked by fetching zone
    const zone = await prisma.zone.findUnique({ where: { id: zoneId }, include: { project: true } });
    if (!zone || zone.project.userId !== userId) throw new Error("Unauthorized or zone not found");
    return prisma.diffuser.findMany({ where: { zoneId }, orderBy: { createdAt: "asc" } });
  },

  async listAllForUser(userId: number) {
    // find all zones for projects owned by user, then fetch diffusers in those zones
    const zones = await prisma.zone.findMany({ where: { project: { userId } }, select: { id: true } });
    const zoneIds = zones.map((z: { id: string }) => z.id);
    if (zoneIds.length === 0) return [];
    return prisma.diffuser.findMany({ where: { zoneId: { in: zoneIds } }, orderBy: { createdAt: "asc" } });
  },

  async getById(id: string, userId: number) {
    const d = await prisma.diffuser.findUnique({ where: { id }, include: { zone: { include: { project: true } } } });
    if (!d) throw new Error("Not found");
    if (d.zone.project.userId !== userId) throw new Error("Unauthorized");
    return d;
  },

  async update(id: string, userId: number, payload: any) {
    // only allow label, size_input, size_unit, deviceIdentifier changes
    const d = await prisma.diffuser.findUnique({ where: { id }, include: { zone: { include: { project: true } } } });
    if (!d || d.zone.project.userId !== userId) throw new Error("Unauthorized or not found");
    const allowed: any = {};
    if (payload.label !== undefined) allowed.label = payload.label;
    if (payload.size_input !== undefined) allowed.size_input = payload.size_input;
    if (payload.size_unit !== undefined) allowed.size_unit = payload.size_unit;
    if (payload.deviceIdentifier !== undefined) allowed.deviceIdentifier = payload.deviceIdentifier;
    if (Object.keys(allowed).length === 0) throw new Error("No updatable fields provided");
    // if size_unit and input provided, optionally normalize sizeFeet here (or do on readings)
    return prisma.diffuser.update({ where: { id }, data: allowed });
  },

  async move(id: string, userId: number, toZoneId: string, note?: string) {
    const d = await prisma.diffuser.findUnique({ where: { id }, include: { zone: { include: { project: true } } } });
    if (!d || d.zone.project.userId !== userId) throw new Error("Unauthorized or not found");

    // ensure target zone is same project and belongs to user
    const toZone = await prisma.zone.findUnique({ where: { id: toZoneId }, include: { project: true } });
    if (!toZone || toZone.project.userId !== userId) throw new Error("Target zone invalid or not owned");

    // create move record
    await prisma.diffuserMove.create({
      data: {
        diffuserId: id,
        fromZoneId: d.zoneId,
        toZoneId,
        movedBy: userId,
        note: note ?? null,
      },
    });

    // update zoneId; recompute systemName in the new zone (auto-assign next available in target zone)
    const existing = await prisma.diffuser.findMany({ where: { zoneId: toZoneId }, select: { systemName: true } });
    const nums = existing
      .map((x: { systemName: string }) => parseInt(x.systemName.replace(/^Diffuser\s+/i, ""), 10))
      .filter((n: number) => !isNaN(n))
      .sort((a: number, b: number) => a - b);
    let nextNum = 1;
    for (let i = 1; i <= 15; i++) {
      if (!nums.includes(i)) { nextNum = i; break; }
    }
    const newSystemName = `Diffuser ${nextNum}`;
    return prisma.diffuser.update({ where: { id }, data: { zoneId: toZoneId, systemName: newSystemName } });
  },

  async delete(id: string, userId: number) {
    const d = await prisma.diffuser.findUnique({ where: { id }, include: { zone: { include: { project: true } } } });
    if (!d || d.zone.project.userId !== userId) throw new Error("Unauthorized or not found");
    return prisma.diffuser.delete({ where: { id } });
  }
};
